// 인덱스 특징
// 1. 쿼리를 수행시, 인덱스가 없다면 모든 문서를 일일 조회하지만, 
// 인덱스가 있다면 쿼리 작업 검색이 효율적.
// 2. 새로운 문서 생성, 수정, 삭제 빈번히 속도 저하가 생김
// 왜냐하면, 매번 업데이트를 해야 하기 때문에
// 3. 단순 인덱스(해당 필드만 조회시 사용)
// 복합 인덱스(다수의 필드를 대상으로 조회시 사용)
// 4. 복합 인덱스는 순서가 중요
// ex) 제목 : 1, 설명 : -1, 이 형식으로 인덱스를 만들기 때문에,
// 다른 구조로 사용시, 또 자원을 소모해서 사용해야 함.
// 5. 인덱스 구조가 예) 복합 : 제목:1, 설명 : -1 인덱스가 있다면,
// 단일 인덱스 예) 제목 : 1, 복합 인덱스에 포함이 된다는 사실.

// 인덱스 종류.
// 단일키 / 복합키 / 다중키(값이 배열 형태인 곳에 설정)
// 텍스 인덱스 : 범위에 대한 인덱스 사용하는데, 문자열 검색은 범위로 
// 검색을 안하고, 정확안 문자열 일치여부, 각 단어위주로 검색할 때 사용.
// $text 연산자를 사용시, 그래서, 텍스트 인덱스가 필요함.
// 지리 공간적 인덱스 : pdf 참고, 교재 없음
// 해시 인덱스 : 위의 인덱스 종류 값으로 (범위로) 인덱스를 지정했다면
// 값 -> 해쉬(변경) -> 사용함. 장점, 효율적인 메모리 사용 가능
// 단점, 해당 해쉬값이 정확해야 함.
db.rating.insertMany(
    [
        {_id:1, rating:1, user_id:2},
        {_id:2, rating:2, user_id:3},
        {_id:3, rating:3, user_id:4},
        {_id:4, rating:3, user_id:1},
        {_id:5, rating:4, user_id:5},
        {_id:6, rating:4, user_id:8},
        {_id:7, rating:5, user_id:9},
        {_id:8, rating:5, user_id:10},
        {_id:9, rating:5, user_id:11},
        {_id:10, rating:5, user_id:12}
    ]
)

// 교재에서 간단한 구조의 인덱스 예제
// 단일키
db.rating.createIndex(
    // 시스템에서, rating 기준으로, 인덱스 만들어 준다
    // 우리는 단일 키 이라서, 해당 rating으로 검색시 효율적인 검색(빠르다)
    // 1: 오름차순, -1:내림차순
    {rating:1}
)


// 복합키 인덱스
db.rating.createIndex(
    // 의미, 1차적으로 rating 필드를 기준으로 정렬을 함.
    // 그리고 나서, 두번째 키, user_id를 정렬
    // 임시 예제.
    // 기준이 되는 키 : rating(1) 중복이 많이 되는 경우, 2) 좀 더 포괄적인
    // 제약 조건이 정할 때, 큰 범주를 잡고, 작은 범주를 선택
    {raging:1, user_id:-1}
);

// 다중키 인덱스
// 값이 배열인 형식에 사용
// 임시 필드를 예
db.ratinf.createIndex(
    // 필드의 값의 타입이 배열 일 경우. 
    {"리뷰.제목" : 1}
)

//텍스트 인덱스 : 문자열 형식의 인덱스
db.rating.createIndex(
    {제목 : "text"}
)

// 해시 인덱스 : 값을 -> 해쉬(특정값으로 변경)
// 값의 일치 여부가 중요한 곳에 사용.
// 예) 영화사 이름처럼 값이 꼭 일치해야 하는 부분
// 예) 고유값에 설정 함
db.rating.createIndex(
    {"배급사" : hashed}
)

// 인덱스의 부가적인 옵션이 5가지정도 있는데,
// 나중에 교재를 한번 참고







